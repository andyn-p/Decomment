#include <stdio.h>
#include <stdlib.h>

/* ascii values of interest */
int NEWLINE      = 10;
int SPACE        = 32;
int STR_LITERAL  = 34;
int CHR_LITERAL  = 39;
int ASTERICK     = 42;
int FORWARDSLASH = 47;
int BACKSLASH    = 92;

/* store lines number as global so functions can access it */
int lines = 0;

/*  enumerate all state types */
enum StateType {BASE, COMMENT, INCOM, OUTCOM, STR, CHR, STRBACK, CHRBACK};

/* handles the base case state */
int handleBase(int c) {
  enum StateType state = BASE;
  if (c == FORWARDSLASH)     { 
    state = INCOM;
  } else if (c == STR_LITERAL) {
    putchar(c);
    state = STR;
  } else if (c == CHR_LITERAL) {
    putchar(c);
    state = CHR;
  } else {
    putchar(c);
    if (c == NEWLINE) {
      lines++;
    }
  }
  return state;
}

/* handles potnetially entering comment */
int handleInComment(int c) {
  enum StateType state = BASE;
  if (c == ASTERICK) {
    putchar(SPACE);
    state = COMMENT;
  } else if (c == FORWARDSLASH) {
    putchar(FORWARDSLASH);
    state = INCOM;
  } else if (c == STR_LITERAL) {
    putchar(FORWARDSLASH);
    putchar(c);
    state = STR;
  } else if (c == CHR_LITERAL) {
    putchar(FORWARDSLASH);
    putchar(c);
    state = CHR;
  } else {
    putchar(FORWARDSLASH);
    putchar(c);
    if (c == NEWLINE) {
      lines++;
    }
  }
  return state;
}

/* handles the comment case state */
int handleComment(int c) {
  enum StateType state = COMMENT;
  if (c == ASTERICK) {
    state = OUTCOM;
  } else if (c == NEWLINE) {
    putchar(NEWLINE);
    lines++;
  }
  return state;
}

/* handles potentially leaving a comment */
int handleOutComment(int c) {
  enum StateType state = COMMENT;
  if (c == FORWARDSLASH) {
    state = BASE;
  } else if (c == ASTERICK) {
    state = OUTCOM;
  } else if (c == NEWLINE) {
    putchar(NEWLINE);
    lines++;
  }
  return state;
}

/* handles being in a string literal */
int handleStrLiteral(int c) {
  enum StateType state = STR;
  putchar(c);
  if (c == NEWLINE) {
    lines++;
  }
  if (c == BACKSLASH) {
    state = STRBACK;
  } else if (c == STR_LITERAL) {
    state = BASE;
  } 
  return state;
}

/* handles being in a string backslash */
int handleStrBackslash(int c) {
  putchar(c);
  if (c == NEWLINE) {
    lines++;
  }
  return STR;
}

/* handles being in a character literal */
int handleChrLiteral(int c) {
  enum StateType state = CHR;
  putchar(c);
  if (c == NEWLINE) {
    lines++;
  }
  if (c == BACKSLASH) {
    state = CHRBACK;
  } else if (c == CHR_LITERAL) {
    state = BASE;
  }
  return state;
}

/* handles being in a character literal */
int handleChrBackslash(int c) {
  putchar(c);
  if (c == NEWLINE) {
    lines++;
  }
  return CHR;
}

int main(void) {

  enum StateType state = BASE;
  int exitStatus = EXIT_SUCCESS;
  int lastCommentLine;
  int c;
  while ((c = getchar()) != EOF) {
    switch (state) {
      case BASE:
        state = handleBase(c);
        break;
      case INCOM:
        state = handleInComment(c);
        break;
      case COMMENT:
        state = handleComment(c);
        break;
      case OUTCOM:
        state = handleOutComment(c);
        break;
      case STR:
        state = handleStrLiteral(c);
        break;
      case CHR:
        state = handleChrLiteral(c);
        break;
      case STRBACK:
        state = handleStrBackslash(c);
        break;
      case CHRBACK:
        state = handleChrBackslash(c);
    }
    if (state == COMMENT) {
      lastCommentLine = lines - 1;
    }
  }
  if (state == INCOM) {
    putchar(FORWARDSLASH);
  }
  if (state == COMMENT || state == OUTCOM) {
    fprintf(stderr, "Error: line %i: unterminated comment", lastCommentLine);
    exit(EXIT_FAILURE);
  }

  return exitStatus;
}
